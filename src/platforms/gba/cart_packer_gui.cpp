#include <windows.h>
#include <commdlg.h>
#include <shlobj.h>
#include <process.h>

#include <cctype>
#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <chrono>
#include <string>
#include <thread>
#include <vector>

#include <lodePNG.h>

#include "cart_blob.h"
#include "../../hal/real8_host.h"
#include "../../core/real8_cart.h"

namespace {
    const int kPadding = 12;
    const int kButtonWidth = 110;
    const int kButtonHeight = 28;
    const int kRowGap = 12;
    const int kCheckboxHeight = 20;
    const int kCheckboxRowGap = 6;
    const int kCheckboxColumnGap = 16;

    const int kIdBrowseCart = 1004;
    const int kIdGenerate = 1005;
    const int kIdSpinner = 1006;
    const int kIdBrowseSkin = 1007;
    const int kIdReset = 1008;
    const int kIdToggleAudio = 1101;
    const int kIdToggleCflahBase = 1102;
    const int kIdToggleSkipVblank = 1103;
    const int kIdToggleProfile = 1104;

    const UINT kIdSpinnerTimer = 2001;
    const UINT kMsgBuildDone = WM_APP + 1;

    // RCDATA resource ID for embedded REAL8_GBA_template.gba (generated by Makefile when EMBED_TEMPLATE=1)
    const int kTemplateResourceId = 201;
    const int kLogoPngResourceId = 202;
    const char* kIconResourceName = "IDI_ICON1";

    HWND g_cartEdit = nullptr;
    HWND g_skinEdit = nullptr;
    HWND g_generateButton = nullptr;
    HWND g_resetButton = nullptr;
    HWND g_spinner = nullptr;
    HWND g_browseCartButton = nullptr;
    HWND g_browseSkinButton = nullptr;
    HWND g_toggleAudio = nullptr;
    HWND g_toggleCflahBase = nullptr;
    HWND g_toggleSkipVblank = nullptr;
    HWND g_toggleProfile = nullptr;
    HWND g_logoImage = nullptr;
    HBRUSH g_windowBrush = nullptr;
    HBITMAP g_logoBitmap = nullptr;

    char g_makePath[MAX_PATH] = "";
    char g_devkitProPath[MAX_PATH] = "";
    char g_gbaDir[MAX_PATH] = "";
    char g_cartPath[MAX_PATH] = "";
    char g_skinPath[MAX_PATH] = "";

    // ---------------------------------------------------------------------------------
    // Standalone template patcher helpers
    // ---------------------------------------------------------------------------------

    // Forward declarations (helpers are defined further down in this file)
    static bool getExeDir(char* out, size_t outSize);
    static bool buildPath(const char* dir, const char* file, char* out, size_t outSize);
    static bool fileExists(const char* path);
    static bool getParentDir(const char* path, char* out, size_t outSize);

    static bool hasEmbeddedResource(int resourceId) {
        HRSRC r = FindResourceA(nullptr, MAKEINTRESOURCEA(resourceId), RT_RCDATA);
        return r != nullptr;
    }

    static bool loadEmbeddedResource(int resourceId, std::vector<uint8_t>& out, const char* label, std::string& err) {
        HRSRC r = FindResourceA(nullptr, MAKEINTRESOURCEA(resourceId), RT_RCDATA);
        if (!r) {
            err = std::string("Embedded ") + label + " not found in this executable.";
            return false;
        }
        DWORD sz = SizeofResource(nullptr, r);
        if (sz == 0) {
            err = std::string("Embedded ") + label + " is empty.";
            return false;
        }
        HGLOBAL h = LoadResource(nullptr, r);
        if (!h) {
            err = std::string("Failed to load embedded ") + label + " resource.";
            return false;
        }
        void* p = LockResource(h);
        if (!p) {
            err = std::string("Failed to access embedded ") + label + " resource.";
            return false;
        }
        out.assign((const uint8_t*)p, (const uint8_t*)p + sz);
        return true;
    }

    static bool hasEmbeddedTemplate() {
        return hasEmbeddedResource(kTemplateResourceId);
    }

    static bool loadEmbeddedTemplate(std::vector<uint8_t>& out, std::string& err) {
        return loadEmbeddedResource(kTemplateResourceId, out, "template ROM", err);
    }

    static bool loadEmbeddedLogoPng(std::vector<uint8_t>& out, std::string& err) {
        return loadEmbeddedResource(kLogoPngResourceId, out, "logo PNG", err);
    }


    class PackerHost : public IReal8Host {
    public:
        const char* getPlatform() const override { return "Pico2GBA"; }

        void setNetworkActive(bool active) override { (void)active; }
        void setWifiCredentials(const char* ssid, const char* pass) override { (void)ssid; (void)pass; }

        void flipScreen(const uint8_t *framebuffer, int fb_w, int fb_h, uint8_t* palette_map) override {
            (void)framebuffer;
            (void)fb_w;
            (void)fb_h;
            (void)palette_map;
        }

        unsigned long getMillis() override {
            using clock = std::chrono::steady_clock;
            static const auto start = clock::now();
            auto now = clock::now();
            return (unsigned long)std::chrono::duration_cast<std::chrono::milliseconds>(now - start).count();
        }

        void log(const char* fmt, ...) override {
            // Pico2GBA GUI: keep logs quiet (errors are surfaced via message box)
            (void)fmt;
        }

        void delayMs(int ms) override {
            if (ms > 0) std::this_thread::sleep_for(std::chrono::milliseconds(ms));
        }

        std::vector<uint8_t> loadFile(const char* path) override { (void)path; return {}; }
        std::vector<std::string> listFiles(const char* ext) override { (void)ext; return {}; }
        bool saveState(const char* filename, const uint8_t* data, size_t size) override { (void)filename; (void)data; (void)size; return false; }
        std::vector<uint8_t> loadState(const char* filename) override { (void)filename; return {}; }
        bool hasSaveState(const char* filename) override { (void)filename; return false; }
        void deleteFile(const char* path) override { (void)path; }
        void getStorageInfo(size_t& used, size_t& total) override { used = 0; total = 0; }
        bool renameGameUI(const char* currentPath) override { (void)currentPath; return false; }
        uint32_t getPlayerInput(int playerIdx) override { (void)playerIdx; return 0; }
        void pollInput() override {}
        void openGamepadConfigUI() override {}
        std::vector<uint8_t> getInputConfigData() override { return {}; }
        void setInputConfigData(const std::vector<uint8_t>& data) override { (void)data; }
        void pushAudio(const int16_t* samples, int count) override { (void)samples; (void)count; }
        NetworkInfo getNetworkInfo() override { return {false, "", "Offline", 0.0f}; }
        bool downloadFile(const char* url, const char* savePath) override { (void)url; (void)savePath; return false; }
        void takeScreenshot() override {}
        void drawWallpaper(const uint8_t* pixels, int w, int h) override { (void)pixels; (void)w; (void)h; }
        void clearWallpaper() override {}
        void updateOverlay() override {}
    };

    static bool readFileBytes(const char* path, std::vector<uint8_t>& out, std::string& err) {
        FILE* f = fopen(path, "rb");
        if (!f) {
            err = std::string("Failed to open ") + path;
            return false;
        }
        fseek(f, 0, SEEK_END);
        long sz = ftell(f);
        if (sz <= 0) {
            fclose(f);
            err = std::string("File is empty: ") + path;
            return false;
        }
        fseek(f, 0, SEEK_SET);
        out.resize((size_t)sz);
        if (fread(out.data(), 1, out.size(), f) != out.size()) {
            fclose(f);
            err = std::string("Failed to read: ") + path;
            return false;
        }
        fclose(f);
        return true;
    }

    static bool writeFileBytes(const char* path, const std::vector<uint8_t>& data, std::string& err) {
        FILE* f = fopen(path, "wb");
        if (!f) {
            err = std::string("Failed to open for writing: ") + path;
            return false;
        }
        if (!data.empty() && fwrite(data.data(), 1, data.size(), f) != data.size()) {
            fclose(f);
            err = std::string("Failed to write: ") + path;
            return false;
        }
        fclose(f);
        return true;
    }

    static bool buildDefaultTemplatePath(char* out, size_t outSize) {
        char exeDir[MAX_PATH] = "";
        if (!getExeDir(exeDir, sizeof(exeDir))) return false;
        if (!buildPath(exeDir, "REAL8_GBA_template.gba", out, outSize)) return false;
        return true;
    }

    static bool findLogoPath(char* out, size_t outSize) {
        char exeDir[MAX_PATH] = "";
        if (!getExeDir(exeDir, sizeof(exeDir))) return false;

        char currentDir[MAX_PATH] = "";
        snprintf(currentDir, sizeof(currentDir), "%s", exeDir);
        for (int i = 0; i < 4; ++i) {
            char candidate[MAX_PATH] = "";
            if (buildPath(currentDir, "REAL8-banner.png", candidate, sizeof(candidate)) &&
                fileExists(candidate)) {
                if (strlen(candidate) + 1 > outSize) return false;
                strcpy(out, candidate);
                return true;
            }
            if (buildPath(currentDir, "src\\platforms\\gba\\REAL8-banner.png", candidate, sizeof(candidate)) &&
                fileExists(candidate)) {
                if (strlen(candidate) + 1 > outSize) return false;
                strcpy(out, candidate);
                return true;
            }
            char parentDir[MAX_PATH] = "";
            if (!getParentDir(currentDir, parentDir, sizeof(parentDir))) break;
            snprintf(currentDir, sizeof(currentDir), "%s", parentDir);
        }
        return false;
    }

    static bool buildCartBlobFromPng(const char* cartPath, std::vector<uint8_t>& outBlob, std::string& err) {
        std::vector<uint8_t> pngBytes;
        if (!readFileBytes(cartPath, pngBytes, err)) return false;

        PackerHost host;
        GameData game;
        if (!Real8CartLoader::LoadFromBuffer(&host, pngBytes, game)) {
            err = std::string("Failed to decode cart: ") + cartPath;
            return false;
        }

        std::vector<uint8_t> payload;
        payload.reserve(0x4300 + game.lua_code.size());
        payload.insert(payload.end(), game.gfx, game.gfx + sizeof(game.gfx));
        payload.insert(payload.end(), game.map, game.map + sizeof(game.map));
        payload.insert(payload.end(), game.sprite_flags, game.sprite_flags + sizeof(game.sprite_flags));
        payload.insert(payload.end(), game.music, game.music + sizeof(game.music));
        payload.insert(payload.end(), game.sfx, game.sfx + sizeof(game.sfx));
        payload.insert(payload.end(), game.lua_code.begin(), game.lua_code.end());

        CartBlobHeader header{};
        memcpy(header.magic, CART_BLOB_MAGIC, CART_BLOB_MAGIC_SIZE);
        header.flags = CART_BLOB_FLAG_NONE;
        header.raw_size = (uint32_t)payload.size();
        header.comp_size = (uint32_t)payload.size();

        outBlob.resize(sizeof(CartBlobHeader) + payload.size());
        memcpy(outBlob.data(), &header, sizeof(CartBlobHeader));
        memcpy(outBlob.data() + sizeof(CartBlobHeader), payload.data(), payload.size());
        return true;
    }

    static uint8_t computeGbaHeaderChecksum(const std::vector<uint8_t>& rom) {
        // GBA header checksum byte at 0xBD covers 0xA0..0xBC.
        // See GBATEK / gbafix.
        if (rom.size() < 0xBE) return 0;
        uint8_t sum = 0;
        for (size_t i = 0xA0; i <= 0xBC; ++i) {
            sum = (uint8_t)(sum + rom[i]);
        }
        return (uint8_t)(0 - (sum + 0x19));
    }

    static bool findTemplateBlobSlot(const std::vector<uint8_t>& rom, size_t& slotOffset, uint32_t& slotCapacity, std::string& err) {
        const size_t hdrSize = sizeof(CartBlobHeader);
        if (rom.size() < hdrSize + 0xC0) {
            err = "Template ROM is too small.";
            return false;
        }

        for (size_t i = 0; i + hdrSize <= rom.size(); ++i) {
            if (memcmp(&rom[i], CART_BLOB_MAGIC, CART_BLOB_MAGIC_SIZE) != 0) continue;

            CartBlobHeader h{};
            memcpy(&h, &rom[i], hdrSize);
            if (memcmp(h.magic, CART_BLOB_MAGIC, CART_BLOB_MAGIC_SIZE) != 0) continue;
            if (h.flags != CART_BLOB_FLAG_NONE) continue;
            if (h.comp_size == 0) continue;

            uint32_t cap = h.comp_size;
            if (i + hdrSize + (size_t)cap > rom.size()) continue;

            // Heuristic: template payload should be all zeros near the start.
            size_t check = cap < 64 ? cap : 64;
            bool looksEmpty = true;
            for (size_t j = 0; j < check; ++j) {
                if (rom[i + hdrSize + j] != 0) { looksEmpty = false; break; }
            }
            if (!looksEmpty) continue;

            slotOffset = i;
            slotCapacity = cap;
            return true;
        }

        err = "Could not find a valid cart blob slot in the template ROM.\n"
              "Make sure you built the template with: make template";
        return false;
    }

    static bool patchTemplateRom(const char* templatePath, const char* cartPath, const char* outputPath, std::string& err) {
        std::vector<uint8_t> rom;

        // Prefer the embedded template if present (true standalone EXE). Fall back to a template ROM file.
        if (hasEmbeddedTemplate()) {
            if (!loadEmbeddedTemplate(rom, err)) return false;
        } else {
            if (!templatePath || !templatePath[0] || !fileExists(templatePath)) {
                err = "Template ROM not found.\n\n"
                      "Build a standalone Pico2GBA with: make tools\n"
                      "(this embeds REAL8_GBA_template.gba into pico2gba.exe)\n\n"
                      "Or build the file template with: make template\n"
                      "and place REAL8_GBA_template.gba next to pico2gba.exe.";

                return false;
            }
            if (!readFileBytes(templatePath, rom, err)) return false;
        }

        std::vector<uint8_t> blob;
        if (!buildCartBlobFromPng(cartPath, blob, err)) return false;
        if (blob.size() < sizeof(CartBlobHeader)) {
            err = "Internal error: blob too small.";
            return false;
        }

        size_t slotOff = 0;
        uint32_t slotCap = 0;
        if (!findTemplateBlobSlot(rom, slotOff, slotCap, err)) return false;

        const size_t hdrSize = sizeof(CartBlobHeader);
        const size_t payloadSize = blob.size() - hdrSize;
        if (payloadSize > slotCap) {
            char buf[256];
            snprintf(buf, sizeof(buf),
                     "Cart is too large for this template slot.\n\n"
                     "Cart payload: %u bytes\nSlot capacity: %u bytes\n\n"
                     "Rebuild the template with a larger CART_TEMPLATE_CAPACITY.",
                     (unsigned)payloadSize, (unsigned)slotCap);
            err = buf;
            return false;
        }

        // Overwrite header + payload, then clear the remaining slot bytes.
        memcpy(&rom[slotOff], blob.data(), hdrSize);
        memcpy(&rom[slotOff + hdrSize], blob.data() + hdrSize, payloadSize);
        if (slotCap > payloadSize) {
            memset(&rom[slotOff + hdrSize + payloadSize], 0, (size_t)(slotCap - payloadSize));
        }

        // Fix GBA header checksum after modifying the ROM.
        if (rom.size() > 0xBD) {
            rom[0xBD] = computeGbaHeaderChecksum(rom);
        }

        return writeFileBytes(outputPath, rom, err);
    }

    bool g_building = false;
    HANDLE g_buildThread = nullptr;

    struct ToggleState {
        int enableAudio;
        int skipVblank;
        int profileGba;
        int cflahBase;
    };

    const ToggleState kDefaultToggles = { 0, 1, 0, 0 };

    struct BuildParams {
        HWND hwnd;
        std::string makePath;
        std::string devkitArmPath;
        std::string devkitProPath;
        std::string cartPath;
        std::string customSkinPath;
        std::string gbaDir;
        std::string outputPath;
        std::string logPath;
        ToggleState toggles;
    };

    struct BuildResult {
        bool success;
        std::string message;
    };

    static bool endsWithIgnoreCase(const char* str, const char* suffix) {
        if (!str || !suffix) return false;
        size_t len = strlen(str);
        size_t sufLen = strlen(suffix);
        if (sufLen > len) return false;
        const char* a = str + (len - sufLen);
        for (size_t i = 0; i < sufLen; ++i) {
            if (std::tolower((unsigned char)a[i]) != std::tolower((unsigned char)suffix[i])) {
                return false;
            }
        }
        return true;
    }

    static bool startsWithIgnoreCase(const char* str, const char* prefix) {
        if (!str || !prefix) return false;
        size_t len = strlen(prefix);
        for (size_t i = 0; i < len; ++i) {
            if (!str[i]) return false;
            if (std::tolower((unsigned char)str[i]) != std::tolower((unsigned char)prefix[i])) {
                return false;
            }
        }
        return true;
    }


    static void updateGenerateEnabled() {
        // Standalone mode: require a template ROM (embedded or file) + a cart file.
        bool templateOk = hasEmbeddedTemplate() || (g_makePath[0] != '\0' && fileExists(g_makePath));
        bool ready = templateOk
            && g_cartPath[0] != '\0' && fileExists(g_cartPath);
        EnableWindow(g_generateButton, ready);
    }

    static bool buildOutputPath(const char* input, char* out, size_t outSize) {
        if (!input || !*input || !out || outSize == 0) return false;

        const char* lastSlash = strrchr(input, '\\');
        const char* lastFwd = strrchr(input, '/');
        const char* sep = lastSlash;
        if (!sep || (lastFwd && lastFwd > sep)) sep = lastFwd;

        size_t dirLen = sep ? (size_t)(sep - input + 1) : 0;
        const char* name = sep ? sep + 1 : input;
        size_t nameLen = strlen(name);

        size_t baseLen = nameLen;
        if (endsWithIgnoreCase(name, ".p8.png")) {
            baseLen = nameLen - 7;
        } else if (endsWithIgnoreCase(name, ".png")) {
            baseLen = nameLen - 4;
        } else {
            const char* dot = strrchr(name, '.');
            if (dot) baseLen = (size_t)(dot - name);
        }

        const char* outExt = ".gba";
        size_t outExtLen = strlen(outExt);

        if (dirLen + baseLen + outExtLen + 1 > outSize) return false;
        if (dirLen > 0) memcpy(out, input, dirLen);
        memcpy(out + dirLen, name, baseLen);
        memcpy(out + dirLen + baseLen, outExt, outExtLen);
        out[dirLen + baseLen + outExtLen] = '\0';
        return true;
    }

    static bool getExeDir(char* out, size_t outSize) {
        if (!out || outSize == 0) return false;
        char path[MAX_PATH] = "";
        DWORD len = GetModuleFileNameA(nullptr, path, MAX_PATH);
        if (len == 0 || len >= MAX_PATH) return false;
        char* lastSlash = strrchr(path, '\\');
        char* lastFwd = strrchr(path, '/');
        char* sep = lastSlash;
        if (!sep || (lastFwd && lastFwd > sep)) sep = lastFwd;
        if (!sep) return false;
        *sep = '\0';
        if (strlen(path) + 1 > outSize) return false;
        strcpy(out, path);
        return true;
    }

    static bool getDirFromPath(const char* path, char* out, size_t outSize) {
        if (!path || !*path || !out || outSize == 0) return false;
        const char* lastSlash = strrchr(path, '\\');
        const char* lastFwd = strrchr(path, '/');
        const char* sep = lastSlash;
        if (!sep || (lastFwd && lastFwd > sep)) sep = lastFwd;
        if (!sep) return false;
        size_t len = (size_t)(sep - path);
        if (len + 1 > outSize) return false;
        memcpy(out, path, len);
        out[len] = '\0';
        return true;
    }

    static bool getParentDir(const char* path, char* out, size_t outSize) {
        if (!path || !*path || !out || outSize == 0) return false;
        size_t len = strlen(path);
        while (len > 0 && (path[len - 1] == '\\' || path[len - 1] == '/')) {
            --len;
        }
        if (len == 0) return false;
        const char* lastSlash = nullptr;
        for (size_t i = 0; i < len; ++i) {
            if (path[i] == '\\' || path[i] == '/') lastSlash = path + i;
        }
        if (!lastSlash) return false;
        size_t outLen = (size_t)(lastSlash - path);
        if (outLen + 1 > outSize) return false;
        memcpy(out, path, outLen);
        out[outLen] = '\0';
        return true;
    }

    static bool fileExists(const char* path) {
        DWORD attr = GetFileAttributesA(path);
        return (attr != INVALID_FILE_ATTRIBUTES) && ((attr & FILE_ATTRIBUTE_DIRECTORY) == 0);
    }

    static bool dirExists(const char* path) {
        DWORD attr = GetFileAttributesA(path);
        return (attr != INVALID_FILE_ATTRIBUTES) && ((attr & FILE_ATTRIBUTE_DIRECTORY) != 0);
    }

    static COLORREF getWindowBackgroundColor(HWND hwnd) {
        if (!hwnd) {
            return GetSysColor(COLOR_WINDOW);
        }
        HBRUSH brush = (HBRUSH)GetClassLongPtr(hwnd, GCLP_HBRBACKGROUND);
        if (brush) {
            LOGBRUSH lb{};
            if (GetObject(brush, sizeof(lb), &lb) == sizeof(lb) && lb.lbStyle == BS_SOLID) {
                return lb.lbColor;
            }
        }
        return GetSysColor(COLOR_WINDOW);
    }

    static HBITMAP createBitmapFromRgba(const unsigned char* image, unsigned w, unsigned h,
                                        int maxW, int maxH, COLORREF bgColor,
                                        int* outW, int* outH, std::string& err) {
        if (!image || w == 0 || h == 0) {
            err = "Invalid logo image data.";
            return nullptr;
        }

        int dstW = (int)w;
        int dstH = (int)h;
        if (maxW > 0 || maxH > 0) {
            double scaleW = maxW > 0 ? (double)maxW / (double)w : 1.0;
            double scaleH = maxH > 0 ? (double)maxH / (double)h : 1.0;
            double scale = scaleW < scaleH ? scaleW : scaleH;
            if (scale <= 0.0) scale = 1.0;
            dstW = (int)(w * scale + 0.5);
            dstH = (int)(h * scale + 0.5);
        }
        if (dstW < 1) dstW = 1;
        if (dstH < 1) dstH = 1;
        if (outW) *outW = dstW;
        if (outH) *outH = dstH;

        BITMAPINFO bmi{};
        bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        bmi.bmiHeader.biWidth = dstW;
        bmi.bmiHeader.biHeight = -dstH;
        bmi.bmiHeader.biPlanes = 1;
        bmi.bmiHeader.biBitCount = 32;
        bmi.bmiHeader.biCompression = BI_RGB;

        void* bits = nullptr;
        HBITMAP bmp = CreateDIBSection(nullptr, &bmi, DIB_RGB_COLORS, &bits, nullptr, 0);
        if (!bmp || !bits) {
            err = "Failed to create logo bitmap.";
            if (bmp) DeleteObject(bmp);
            return nullptr;
        }

        uint8_t bgR = (uint8_t)(bgColor & 0xFF);
        uint8_t bgG = (uint8_t)((bgColor >> 8) & 0xFF);
        uint8_t bgB = (uint8_t)((bgColor >> 16) & 0xFF);

        uint8_t* dst = static_cast<uint8_t*>(bits);
        for (int y = 0; y < dstH; ++y) {
            unsigned srcY = (unsigned)((uint64_t)y * h / (unsigned)dstH);
            for (int x = 0; x < dstW; ++x) {
                unsigned srcX = (unsigned)((uint64_t)x * w / (unsigned)dstW);
                size_t srcIdx = ((size_t)srcY * w + srcX) * 4;
                size_t dstIdx = ((size_t)y * dstW + x) * 4;
                uint8_t srcR = image[srcIdx + 0];
                uint8_t srcG = image[srcIdx + 1];
                uint8_t srcB = image[srcIdx + 2];
                uint8_t srcA = image[srcIdx + 3];
                if (srcA == 255) {
                    dst[dstIdx + 0] = srcB;
                    dst[dstIdx + 1] = srcG;
                    dst[dstIdx + 2] = srcR;
                    dst[dstIdx + 3] = 255;
                } else if (srcA == 0) {
                    dst[dstIdx + 0] = bgB;
                    dst[dstIdx + 1] = bgG;
                    dst[dstIdx + 2] = bgR;
                    dst[dstIdx + 3] = 255;
                } else {
                    uint16_t invA = (uint16_t)(255 - srcA);
                    uint8_t outR = (uint8_t)((srcR * srcA + bgR * invA) / 255);
                    uint8_t outG = (uint8_t)((srcG * srcA + bgG * invA) / 255);
                    uint8_t outB = (uint8_t)((srcB * srcA + bgB * invA) / 255);
                    dst[dstIdx + 0] = outB;
                    dst[dstIdx + 1] = outG;
                    dst[dstIdx + 2] = outR;
                    dst[dstIdx + 3] = 255;
                }
            }
        }

        return bmp;
    }

    static HBITMAP loadPngBitmap(const char* pngPath, int maxW, int maxH, COLORREF bgColor,
                                 int* outW, int* outH, std::string& err) {
        unsigned char* image = nullptr;
        unsigned w = 0, h = 0;
        unsigned error = lodepng_decode32_file(&image, &w, &h, pngPath);
        if (error || !image) {
            err = std::string("Failed to decode logo PNG: ") + pngPath;
            return nullptr;
        }

        HBITMAP bmp = createBitmapFromRgba(image, w, h, maxW, maxH, bgColor, outW, outH, err);
        free(image);
        return bmp;
    }

    static HBITMAP loadPngBitmapFromMemory(const uint8_t* pngData, size_t pngSize, int maxW, int maxH,
                                           COLORREF bgColor, int* outW, int* outH, std::string& err) {
        if (!pngData || pngSize == 0) {
            err = "Embedded logo PNG is empty.";
            return nullptr;
        }

        unsigned char* image = nullptr;
        unsigned w = 0, h = 0;
        unsigned error = lodepng_decode32(&image, &w, &h, pngData, pngSize);
        if (error || !image) {
            err = "Failed to decode embedded logo PNG.";
            return nullptr;
        }

        HBITMAP bmp = createBitmapFromRgba(image, w, h, maxW, maxH, bgColor, outW, outH, err);
        free(image);
        return bmp;
    }

    static bool buildPath(const char* dir, const char* file, char* out, size_t outSize) {
        if (!dir || !file || !out || outSize == 0) return false;
        size_t dirLen = strlen(dir);
        size_t fileLen = strlen(file);
        bool needsSlash = (dirLen > 0 && dir[dirLen - 1] != '\\' && dir[dirLen - 1] != '/');
        size_t total = dirLen + (needsSlash ? 1 : 0) + fileLen + 1;
        if (total > outSize) return false;
        memcpy(out, dir, dirLen);
        size_t offset = dirLen;
        if (needsSlash) out[offset++] = '\\';
        memcpy(out + offset, file, fileLen);
        out[offset + fileLen] = '\0';
        return true;
    }

    static void trimLineEnding(char* line) {
        if (!line) return;
        size_t len = strlen(line);
        while (len > 0 && (line[len - 1] == '\n' || line[len - 1] == '\r')) {
            line[--len] = '\0';
        }
    }

    static bool containsIgnoreCase(const char* str, const char* needle) {
        if (!str || !needle || !*needle) return false;
        size_t needleLen = strlen(needle);
        for (const char* p = str; *p; ++p) {
            size_t i = 0;
            while (i < needleLen && p[i] &&
                   std::tolower((unsigned char)p[i]) == std::tolower((unsigned char)needle[i])) {
                ++i;
            }
            if (i == needleLen) return true;
        }
        return false;
    }

    static bool lineHasRegionStats(const char* line, const char* region) {
        if (!line || !region || !*region) return false;
        size_t regionLen = strlen(region);
        for (const char* p = line; *p; ++p) {
            if (std::tolower((unsigned char)*p) != std::tolower((unsigned char)region[0])) continue;
            size_t i = 1;
            while (i < regionLen && p[i] &&
                   std::tolower((unsigned char)p[i]) == std::tolower((unsigned char)region[i])) {
                ++i;
            }
            if (i != regionLen) continue;
            if (p != line) {
                char before = p[-1];
                if (std::isalnum((unsigned char)before) || before == '_') continue;
            }
            const char* after = p + regionLen;
            while (*after == ' ' || *after == '\t') ++after;
            if (*after == ':' || std::isdigit((unsigned char)*after)) {
                return true;
            }
        }
        return false;
    }

    static bool parseMakeToggleValue(const char* makefilePath, const char* key, int& outValue) {
        if (!makefilePath || !*makefilePath || !key || !*key) return false;
        FILE* file = fopen(makefilePath, "r");
        if (!file) return false;

        char line[512] = "";
        size_t keyLen = strlen(key);
        bool found = false;
        while (fgets(line, sizeof(line), file)) {
            trimLineEnding(line);
            const char* p = line;
            while (*p == ' ' || *p == '\t') ++p;
            if (*p == '#' || *p == '\0') continue;
            if (strncmp(p, key, keyLen) != 0) continue;
            if (p[keyLen] && !std::isspace(static_cast<unsigned char>(p[keyLen])) &&
                p[keyLen] != '?' && p[keyLen] != '=') {
                continue;
            }
            const char* assign = strstr(p + keyLen, "?=");
            if (!assign) {
                assign = strchr(p + keyLen, '=');
                if (assign) {
                    assign += 1;
                }
            } else {
                assign += 2;
            }
            if (!assign) continue;
            while (*assign == ' ' || *assign == '\t') ++assign;
            if (!*assign) continue;
            int value = std::atoi(assign);
            outValue = value ? 1 : 0;
            found = true;
            break;
        }

        fclose(file);
        return found;
    }

    static ToggleState loadToggleDefaultsFromMakefile(const char* gbaDir) {
        ToggleState defaults = kDefaultToggles;
        if (!gbaDir || !*gbaDir) return defaults;

        char makefilePath[MAX_PATH] = "";
        if (!buildPath(gbaDir, "Makefile", makefilePath, sizeof(makefilePath))) {
            return defaults;
        }
        if (!fileExists(makefilePath)) return defaults;

        int value = 0;
        if (parseMakeToggleValue(makefilePath, "REAL8_GBA_ENABLE_AUDIO", value)) {
            defaults.enableAudio = value;
        }
        if (parseMakeToggleValue(makefilePath, "REAL8_GBA_SKIP_VBLANK", value)) {
            defaults.skipVblank = value;
        }
        if (parseMakeToggleValue(makefilePath, "REAL8_PROFILE_GBA", value)) {
            defaults.profileGba = value;
        }
        if (parseMakeToggleValue(makefilePath, "REAL8_GBA_CUSTOM_SKIN", value)) {
            defaults.cflahBase = value;
        }

        return defaults;
    }

    static void setCheckboxState(HWND checkbox, int value) {
        if (!checkbox) return;
        SendMessageA(checkbox, BM_SETCHECK, value ? BST_CHECKED : BST_UNCHECKED, 0);
    }

    static int getCheckboxState(HWND checkbox) {
        if (!checkbox) return 0;
        return SendMessageA(checkbox, BM_GETCHECK, 0, 0) == BST_CHECKED ? 1 : 0;
    }

    static void applyToggleState(const ToggleState& state) {
        setCheckboxState(g_toggleAudio, state.enableAudio);
        setCheckboxState(g_toggleCflahBase, state.cflahBase);
        setCheckboxState(g_toggleSkipVblank, state.skipVblank);
        setCheckboxState(g_toggleProfile, state.profileGba);
    }

    static ToggleState readToggleStateFromUi() {
        ToggleState state = {};
        state.enableAudio = getCheckboxState(g_toggleAudio);
        state.skipVblank = getCheckboxState(g_toggleSkipVblank);
        state.profileGba = getCheckboxState(g_toggleProfile);
        state.cflahBase = getCheckboxState(g_toggleCflahBase);
        return state;
    }

    static void syncToggleDefaultsFromMakefile() {
        ToggleState defaults = loadToggleDefaultsFromMakefile(g_gbaDir);
        applyToggleState(defaults);
    }

    static void ensureCustomSkinToggle() {
        if (g_skinPath[0]) {
            setCheckboxState(g_toggleCflahBase, 1);
        }
    }

    static void appendMakeVar(std::string& args, const char* name, int value) {
        if (!name || !*name) return;
        args.push_back(' ');
        args += name;
        args.push_back('=');
        args += value ? "1" : "0";
    }

    static bool readMemoryUsageFromLog(const char* logPath, std::string& out) {
        if (!logPath || !*logPath) return false;
        FILE* file = fopen(logPath, "r");
        if (!file) return false;

        char line[512] = "";
        std::string header;
        std::string romLine;
        std::string iwramLine;
        std::string ewramLine;

        while (fgets(line, sizeof(line), file)) {
            trimLineEnding(line);
            if (!line[0]) continue;

            if (containsIgnoreCase(line, "Memory region")) {
                header = line;
                continue;
            }

            if (lineHasRegionStats(line, "EWRAM")) {
                ewramLine = line;
            } else if (lineHasRegionStats(line, "IWRAM")) {
                iwramLine = line;
            } else if (lineHasRegionStats(line, "ROM")) {
                romLine = line;
            }
        }

        fclose(file);

        if (romLine.empty() && iwramLine.empty() && ewramLine.empty()) return false;

        out.clear();
        out += "Memory usage:\n";
        if (!header.empty()) {
            out += header;
            out += "\n";
        }
        if (!ewramLine.empty()) {
            out += ewramLine;
            out += "\n";
        }
        if (!iwramLine.empty()) {
            out += iwramLine;
            out += "\n";
        }
        if (!romLine.empty()) {
            out += romLine;
        }
        return true;
    }

    static bool deriveMsysRootFromDir(const char* dir, char* out, size_t outSize) {
        if (!dir || !*dir || !out || outSize == 0) return false;
        const char* suffixes[] = {
            "\\mingw64\\bin",
            "/mingw64/bin",
            "\\mingw32\\bin",
            "/mingw32/bin",
            "\\usr\\bin",
            "/usr/bin"
        };
        for (const char* suffix : suffixes) {
            if (endsWithIgnoreCase(dir, suffix)) {
                size_t dirLen = strlen(dir);
                size_t sufLen = strlen(suffix);
                size_t rootLen = dirLen - sufLen;
                while (rootLen > 0 && (dir[rootLen - 1] == '\\' || dir[rootLen - 1] == '/')) {
                    rootLen--;
                }
                if (rootLen == 0 || rootLen + 1 > outSize) return false;
                memcpy(out, dir, rootLen);
                out[rootLen] = '\0';
                return true;
            }
        }
        return false;
    }

    static void appendPathEntry(std::string& path, const char* entry) {
        if (!entry || !*entry) return;
        if (!path.empty() && path.back() != ';') {
            path.push_back(';');
        }
        path += entry;
    }

    static std::string formatWin32Error(DWORD err) {
        char buffer[256] = "";
        DWORD len = FormatMessageA(
            FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
            nullptr,
            err,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            buffer,
            (DWORD)sizeof(buffer),
            nullptr);
        if (len == 0) {
            return "Unknown error.";
        }
        while (len > 0 && (buffer[len - 1] == '\r' || buffer[len - 1] == '\n')) {
            buffer[--len] = '\0';
        }
        return buffer;
    }

    static bool ensureDirExists(const char* path) {
        if (!path || !*path) return false;
        if (dirExists(path)) return true;
        if (CreateDirectoryA(path, nullptr)) return true;
        DWORD err = GetLastError();
        return err == ERROR_ALREADY_EXISTS;
    }

    static bool buildDriveTmpFromPath(const char* path, char* outWin, size_t outWinSize, char* outPosix, size_t outPosixSize) {
        if (!path || !outWin || outWinSize == 0) return false;
        if (strlen(path) < 2 || path[1] != ':') return false;
        char drive = path[0];
        if (!((drive >= 'A' && drive <= 'Z') || (drive >= 'a' && drive <= 'z'))) return false;
        char upper = (char)std::toupper((unsigned char)drive);
        char lower = (char)std::tolower((unsigned char)drive);
        int written = snprintf(outWin, outWinSize, "%c:\\tmp", upper);
        if (written <= 0 || (size_t)written >= outWinSize) return false;
        if (outPosix && outPosixSize > 0) {
            int posixWritten = snprintf(outPosix, outPosixSize, "/%c/tmp", lower);
            if (posixWritten <= 0 || (size_t)posixWritten >= outPosixSize) {
                outPosix[0] = '\0';
            }
        }
        return true;
    }


    static bool hasMakefile(const char* dir) {
        char path[MAX_PATH] = "";
        if (!buildPath(dir, "Makefile", path, sizeof(path))) return false;
        return fileExists(path);
    }

    static bool getGbaDir(char* out, size_t outSize) {
        char exeDir[MAX_PATH] = "";
        if (!getExeDir(exeDir, sizeof(exeDir))) return false;
        if (hasMakefile(exeDir)) {
            if (strlen(exeDir) + 1 > outSize) return false;
            strcpy(out, exeDir);
            return true;
        }

        char parent[MAX_PATH] = "";
        strcpy(parent, exeDir);
        char* lastSlash = strrchr(parent, '\\');
        char* lastFwd = strrchr(parent, '/');
        char* sep = lastSlash;
        if (!sep || (lastFwd && lastFwd > sep)) sep = lastFwd;
        if (sep) {
            *sep = '\0';
            if (hasMakefile(parent)) {
                if (strlen(parent) + 1 > outSize) return false;
                strcpy(out, parent);
                return true;
            }
        }
        return false;
    }

    static bool deriveDevkitPro(const char* devkitArmPath, char* out, size_t outSize) {
        if (!devkitArmPath || !*devkitArmPath || !out || outSize == 0) return false;
        size_t len = strlen(devkitArmPath);
        while (len > 0 && (devkitArmPath[len - 1] == '\\' || devkitArmPath[len - 1] == '/')) {
            len--;
        }
        if (len < 9) return false;
        std::string trimmed(devkitArmPath, len);
        if (!endsWithIgnoreCase(trimmed.c_str(), "devkitarm")) return false;
        size_t newLen = len - 9;
        if (newLen == 0 || newLen + 1 > outSize) return false;
        memcpy(out, trimmed.c_str(), newLen);
        if (out[newLen - 1] == '\\' || out[newLen - 1] == '/') {
            out[newLen - 1] = '\0';
        } else {
            out[newLen] = '\0';
        }
        return true;
    }

    static bool deriveDevkitArmFromPro(const char* devkitProPath, char* out, size_t outSize) {
        if (!devkitProPath || !*devkitProPath || !out || outSize == 0) return false;
        if (!buildPath(devkitProPath, "devkitARM", out, outSize)) return false;
        return true;
    }

    static bool runMakeCommand(const char* gbaDir, const char* makePath, const char* devkitArmPath, const char* devkitProPath, const ToggleState& toggles, const char* inputPath, const char* logPath, std::string& err) {
        if (!makePath || !*makePath) return false;
        if (!devkitArmPath || !*devkitArmPath) return false;

        std::string args = "V=1 rom CART_PNG=\"";
        args += inputPath;
        args += "\"";
        appendMakeVar(args, "REAL8_GBA_ENABLE_AUDIO", toggles.enableAudio);
        appendMakeVar(args, "REAL8_GBA_SKIP_VBLANK", toggles.skipVblank);
        appendMakeVar(args, "REAL8_PROFILE_GBA", toggles.profileGba);
        appendMakeVar(args, "REAL8_GBA_CUSTOM_SKIN", toggles.cflahBase);

        char makeDir[MAX_PATH] = "";
        if (!getDirFromPath(makePath, makeDir, sizeof(makeDir))) {
            err = "Failed to locate the make executable folder.";
            return false;
        }

        char msysRoot[MAX_PATH] = "";
        char msysUsrBin[MAX_PATH] = "";
        char msysTmp[MAX_PATH] = "";
        if (deriveMsysRootFromDir(makeDir, msysRoot, sizeof(msysRoot))) {
            buildPath(msysRoot, "usr\\bin", msysUsrBin, sizeof(msysUsrBin));
            buildPath(msysRoot, "tmp", msysTmp, sizeof(msysTmp));
        }

        char devkitArmBin[MAX_PATH] = "";
        if (buildPath(devkitArmPath, "bin", devkitArmBin, sizeof(devkitArmBin)) && !dirExists(devkitArmBin)) {
            devkitArmBin[0] = '\0';
        }
        char devkitToolsBin[MAX_PATH] = "";
        if (devkitProPath && devkitProPath[0]) {
            if (buildPath(devkitProPath, "tools\\bin", devkitToolsBin, sizeof(devkitToolsBin)) && !dirExists(devkitToolsBin)) {
                devkitToolsBin[0] = '\0';
            }
        }

        char tempDirWin[MAX_PATH] = "";
        char exeDir[MAX_PATH] = "";
        char exeTmp[MAX_PATH] = "";
        if (getExeDir(exeDir, sizeof(exeDir)) && buildPath(exeDir, "tmp", exeTmp, sizeof(exeTmp)) && ensureDirExists(exeTmp)) {
            snprintf(tempDirWin, sizeof(tempDirWin), "%s", exeTmp);
        } else {
            char cTmp[MAX_PATH] = "C:\\tmp";
            char driveTmpWin[MAX_PATH] = "";
            if (ensureDirExists(cTmp)) {
                snprintf(tempDirWin, sizeof(tempDirWin), "%s", cTmp);
            } else if (buildDriveTmpFromPath(gbaDir, driveTmpWin, sizeof(driveTmpWin), nullptr, 0) &&
                       ensureDirExists(driveTmpWin)) {
                snprintf(tempDirWin, sizeof(tempDirWin), "%s", driveTmpWin);
            } else if (msysTmp[0] && ensureDirExists(msysTmp)) {
                snprintf(tempDirWin, sizeof(tempDirWin), "%s", msysTmp);
            } else {
                DWORD tempLen = GetTempPathA((DWORD)sizeof(tempDirWin), tempDirWin);
                if (tempLen == 0 || tempLen >= sizeof(tempDirWin)) {
                    tempDirWin[0] = '\0';
                }
            }
        }

        std::string existingPath;
        std::vector<std::string> envVars;
        LPCH env = GetEnvironmentStringsA();
        if (env) {
            for (LPCH p = env; *p; ) {
                size_t len = strlen(p);
                if (startsWithIgnoreCase(p, "PATH=")) {
                    existingPath = p + 5;
                } else if (!startsWithIgnoreCase(p, "DEVKITARM=") && !startsWithIgnoreCase(p, "DEVKITPRO=") &&
                           !startsWithIgnoreCase(p, "SHELL=") && !startsWithIgnoreCase(p, "TMP=") &&
                           !startsWithIgnoreCase(p, "TEMP=") && !startsWithIgnoreCase(p, "TMPDIR=")) {
                    envVars.emplace_back(p, len);
                }
                p += len + 1;
            }
            FreeEnvironmentStringsA(env);
        }

        std::string newPath;
        if (msysUsrBin[0] && dirExists(msysUsrBin)) {
            appendPathEntry(newPath, msysUsrBin);
        }
        if (makeDir[0] && dirExists(makeDir)) {
            appendPathEntry(newPath, makeDir);
        }
        if (devkitArmBin[0] && dirExists(devkitArmBin)) {
            appendPathEntry(newPath, devkitArmBin);
        }
        if (devkitToolsBin[0] && dirExists(devkitToolsBin)) {
            appendPathEntry(newPath, devkitToolsBin);
        }
        if (!existingPath.empty()) {
            appendPathEntry(newPath, existingPath.c_str());
        }

        envVars.emplace_back(std::string("DEVKITARM=") + devkitArmPath);
        if (devkitProPath && devkitProPath[0]) {
            envVars.emplace_back(std::string("DEVKITPRO=") + devkitProPath);
        }
        if (!newPath.empty()) {
            envVars.emplace_back(std::string("PATH=") + newPath);
        }
        if (tempDirWin[0]) {
            envVars.emplace_back(std::string("TMP=") + tempDirWin);
            envVars.emplace_back(std::string("TEMP=") + tempDirWin);
            envVars.emplace_back(std::string("TMPDIR=") + tempDirWin);
        }
        envVars.emplace_back("MSYS2_ENV_CONV_EXCL=TMP;TEMP;TMPDIR");
        envVars.emplace_back("REAL8_HOST_CMD=1");
        envVars.emplace_back("SHELL=cmd.exe");

        std::vector<char> envBlock;
        for (const auto& var : envVars) {
            envBlock.insert(envBlock.end(), var.begin(), var.end());
            envBlock.push_back('\0');
        }
        envBlock.push_back('\0');

        SECURITY_ATTRIBUTES sa = {};
        sa.nLength = sizeof(sa);
        sa.bInheritHandle = TRUE;

        HANDLE logHandle = INVALID_HANDLE_VALUE;
        if (logPath && *logPath) {
            logHandle = CreateFileA(logPath, GENERIC_WRITE, FILE_SHARE_READ, &sa, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);
            if (logHandle == INVALID_HANDLE_VALUE) {
                DWORD logErr = GetLastError();
                err = "Failed to open log file. ";
                err += formatWin32Error(logErr);
                return false;
            }
            const char* header = "pico2gba build log\r\n";
            DWORD written = 0;
            WriteFile(logHandle, header, (DWORD)strlen(header), &written, nullptr);
        }

        HANDLE stdIn = GetStdHandle(STD_INPUT_HANDLE);
        HANDLE nullIn = INVALID_HANDLE_VALUE;
        if (stdIn == INVALID_HANDLE_VALUE || stdIn == nullptr) {
            nullIn = CreateFileA("NUL", GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, &sa, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
            if (nullIn == INVALID_HANDLE_VALUE) {
                DWORD logErr = GetLastError();
                err = "Failed to open NUL for stdin. ";
                err += formatWin32Error(logErr);
                if (logHandle != INVALID_HANDLE_VALUE) {
                    CloseHandle(logHandle);
                }
                return false;
            }
            stdIn = nullIn;
        }

        STARTUPINFOA si = {};
        si.cb = sizeof(si);
        si.dwFlags |= STARTF_USESTDHANDLES;
        si.hStdOutput = (logHandle != INVALID_HANDLE_VALUE) ? logHandle : GetStdHandle(STD_OUTPUT_HANDLE);
        si.hStdError = (logHandle != INVALID_HANDLE_VALUE) ? logHandle : GetStdHandle(STD_ERROR_HANDLE);
        si.hStdInput = stdIn;
        PROCESS_INFORMATION pi = {};

        std::string cmd = "\"";
        cmd += makePath;
        cmd += "\" ";
        cmd += args;

        std::vector<char> cmdLine(cmd.begin(), cmd.end());
        cmdLine.push_back('\0');

        BOOL ok = CreateProcessA(
            nullptr,
            cmdLine.data(),
            nullptr,
            nullptr,
            TRUE,
            CREATE_NO_WINDOW,
            envBlock.data(),
            gbaDir,
            &si,
            &pi);

        if (!ok) {
            DWORD lastErr = GetLastError();
            std::string cmd = "cmd.exe /C \"\"";
            cmd += makePath;
            cmd += "\" ";
            cmd += args;
            cmd += "\"";

            std::vector<char> cmdLineShell(cmd.begin(), cmd.end());
            cmdLineShell.push_back('\0');

            ok = CreateProcessA(
                nullptr,
                cmdLineShell.data(),
                nullptr,
                nullptr,
                TRUE,
                CREATE_NO_WINDOW,
                envBlock.data(),
                gbaDir,
                &si,
                &pi);

            if (!ok) {
                DWORD secondErr = GetLastError();
                std::string details = formatWin32Error(secondErr);
                char msg[128] = "";
                snprintf(msg, sizeof(msg), "Failed to launch make (error %lu).", (unsigned long)secondErr);
                err = msg;
                err += " ";
                err += details;
                if (lastErr != secondErr) {
                    err += " (initial error ";
                    err += std::to_string((unsigned long)lastErr);
                    err += ").";
                }
                if (logHandle != INVALID_HANDLE_VALUE) {
                    CloseHandle(logHandle);
                }
                if (nullIn != INVALID_HANDLE_VALUE) {
                    CloseHandle(nullIn);
                }
                return false;
            }
        }

        WaitForSingleObject(pi.hProcess, INFINITE);

        DWORD exitCode = 1;
        GetExitCodeProcess(pi.hProcess, &exitCode);
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
        if (logHandle != INVALID_HANDLE_VALUE) {
            CloseHandle(logHandle);
        }
        if (nullIn != INVALID_HANDLE_VALUE) {
            CloseHandle(nullIn);
        }

        if (exitCode != 0) {
            err = "Build failed. Check the log for details.";
            if (logPath && *logPath) {
                err += "\n";
                err += logPath;
            }
            return false;
        }

        return true;
    }

    static bool runMake(const char* gbaDir, const char* makePath, const char* devkitArmPath, const char* devkitProPath, const ToggleState& toggles, const char* inputPath, const char* logPath, std::string& err) {
        if (runMakeCommand(gbaDir, makePath, devkitArmPath, devkitProPath, toggles, inputPath, logPath, err)) return true;
        if (err.empty()) {
            err = "Failed to launch make. Check the selected path and permissions.";
        }
        return false;
    }

    static bool copyBuiltRom(const char* gbaDir, const char* outputPath, std::string& err) {
        char builtPath[MAX_PATH] = "";
        if (!buildPath(gbaDir, "REAL8_GBA.gba", builtPath, sizeof(builtPath))) {
            err = "Failed to locate build output.";
            return false;
        }
        if (!fileExists(builtPath)) {
            err = "Build output not found.";
            return false;
        }
        if (_stricmp(builtPath, outputPath) == 0) {
            return true;
        }
        if (!MoveFileExA(builtPath, outputPath, MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED)) {
            DWORD moveErr = GetLastError();
            err = "Failed to move output file. ";
            err += formatWin32Error(moveErr);
            return false;
        }
        return true;
    }

    static void deleteCartBlob(const char* gbaDir) {
        char blobPath[MAX_PATH] = "";
        if (buildPath(gbaDir, "cart_blob.bin", blobPath, sizeof(blobPath))) {
            DeleteFileA(blobPath);
        }
    }

    static void clearPathValue(char* path, HWND edit) {
        if (path) {
            path[0] = '\0';
        }
        if (edit) {
            SetWindowTextA(edit, "");
        }
    }

    static bool copyCustomSkinFile(const char* gbaDir, const char* skinPath, std::string& err) {
        if (!skinPath || !*skinPath) return true;
        if (!fileExists(skinPath)) {
            err = "Selected custom skin file not found.";
            return false;
        }
        char destPath[MAX_PATH] = "";
        if (!buildPath(gbaDir, "custom_skin.png", destPath, sizeof(destPath))) {
            err = "Failed to build custom skin destination path.";
            return false;
        }
        if (_stricmp(skinPath, destPath) == 0) {
            return true;
        }
        if (!CopyFileA(skinPath, destPath, FALSE)) {
            DWORD copyErr = GetLastError();
            err = "Failed to copy custom skin file. ";
            err += formatWin32Error(copyErr);
            return false;
        }
        return true;
    }

    static void setSelectedMake(const char* path) {
        if (!path) return;
        snprintf(g_makePath, sizeof(g_makePath), "%s", path);
        updateGenerateEnabled();
    }

    static void setSelectedDevkitPro(const char* path) {
        if (!path) return;
        snprintf(g_devkitProPath, sizeof(g_devkitProPath), "%s", path);
        updateGenerateEnabled();
    }

    static void setSelectedGbaDir(const char* path) {
        if (!path) return;
        snprintf(g_gbaDir, sizeof(g_gbaDir), "%s", path);
        updateGenerateEnabled();
    }

    static void setSelectedCart(const char* path) {
        if (!path) return;
        snprintf(g_cartPath, sizeof(g_cartPath), "%s", path);
        SetWindowTextA(g_cartEdit, g_cartPath);
        updateGenerateEnabled();
    }

    static void setSelectedCustomSkin(const char* path) {
        if (!path) return;
        snprintf(g_skinPath, sizeof(g_skinPath), "%s", path);
        SetWindowTextA(g_skinEdit, g_skinPath);
        setCheckboxState(g_toggleCflahBase, 1);
        updateGenerateEnabled();
    }

    static void showMessage(const char* text, UINT flags) {
        MessageBoxA(nullptr, text, "Pico2GBA", flags);
    }

    static void startSpinner(HWND hwnd) {
        if (g_spinner) {
            SetWindowTextA(g_spinner, "|");
            ShowWindow(g_spinner, SW_SHOW);
        }
        g_building = true;
        SetTimer(hwnd, kIdSpinnerTimer, 100, nullptr);
    }

    static void stopSpinner(HWND hwnd) {
        KillTimer(hwnd, kIdSpinnerTimer);
        g_building = false;
        if (g_spinner) {
            SetWindowTextA(g_spinner, "");
        }
    }

    static unsigned __stdcall buildThreadProc(void* param) {
        BuildParams* params = static_cast<BuildParams*>(param);
        BuildResult* result = new BuildResult();
        std::string err;

        // Standalone mode: patch the selected cart into the template ROM.
        bool ok = patchTemplateRom(
            params->makePath.c_str(),
            params->cartPath.c_str(),
            params->outputPath.c_str(),
            err);
        if (!ok) {
            result->success = false;
            result->message = err;
        } else {
            result->success = true;
            result->message = "Generated:\n";
            result->message += params->outputPath;
        }

        PostMessageA(params->hwnd, kMsgBuildDone, result->success ? 1 : 0, reinterpret_cast<LPARAM>(result));
        delete params;
        return 0;
    }

    static void applyDefaultPaths() {
        if (!g_makePath[0]) {
            char tpl[MAX_PATH] = "";
            // The GUI is now standalone: by default we expect the template ROM to sit next to the exe.
            if (buildDefaultTemplatePath(tpl, sizeof(tpl))) {
                // Don't require it to exist yet; if it's missing, we'll show a friendly error on Generate.
                setSelectedMake(tpl);
            }
        }
    }

    static void handleBrowseMake(HWND owner) {
        char filePath[MAX_PATH] = "";
        OPENFILENAMEA ofn = {};
        ofn.lStructSize = sizeof(ofn);
        ofn.hwndOwner = owner;
        ofn.lpstrFile = filePath;
        ofn.nMaxFile = sizeof(filePath);
        ofn.lpstrFilter = "GBA ROM Template (*.gba)\0*.gba\0All Files\0*.*\0";
        ofn.nFilterIndex = 1;
        ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_EXPLORER;

        if (GetOpenFileNameA(&ofn)) {
            setSelectedMake(filePath);
        }
    }

    static void handleBrowseDevkitPro(HWND owner) {
        BROWSEINFOA bi = {};
        bi.hwndOwner = owner;
        bi.lpszTitle = "Select devkitPro folder";
        bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE;

        LPITEMIDLIST pidl = SHBrowseForFolderA(&bi);
        if (pidl) {
            char folder[MAX_PATH] = "";
            if (SHGetPathFromIDListA(pidl, folder)) {
                setSelectedDevkitPro(folder);
            }
            CoTaskMemFree(pidl);
        }
    }

    static void handleBrowseGbaDir(HWND owner) {
        BROWSEINFOA bi = {};
        bi.hwndOwner = owner;
        bi.lpszTitle = "Select GBA Makefile folder";
        bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE;

        LPITEMIDLIST pidl = SHBrowseForFolderA(&bi);
        if (pidl) {
            char folder[MAX_PATH] = "";
            if (SHGetPathFromIDListA(pidl, folder)) {
                    if (!hasMakefile(folder)) {
                        showMessage("Makefile not found in the selected folder.", MB_ICONWARNING | MB_OK);
                    } else {
                        setSelectedGbaDir(folder);
                        syncToggleDefaultsFromMakefile();
                        ensureCustomSkinToggle();
                    }
                }
            CoTaskMemFree(pidl);
        }
    }

    static void handleBrowseCart(HWND owner) {
        char filePath[MAX_PATH] = "";
        OPENFILENAMEA ofn = {};
        ofn.lStructSize = sizeof(ofn);
        ofn.hwndOwner = owner;
        ofn.lpstrFile = filePath;
        ofn.nMaxFile = sizeof(filePath);
        ofn.lpstrFilter = "PICO-8 Cart (*.p8.png)\0*.p8.png\0All Files\0*.*\0";
        ofn.nFilterIndex = 1;
        ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_EXPLORER;

        if (GetOpenFileNameA(&ofn)) {
            setSelectedCart(filePath);
        }
    }

    static void handleBrowseCustomSkin(HWND owner) {
        char filePath[MAX_PATH] = "";
        OPENFILENAMEA ofn = {};
        ofn.lStructSize = sizeof(ofn);
        ofn.hwndOwner = owner;
        ofn.lpstrFile = filePath;
        ofn.nMaxFile = sizeof(filePath);
        ofn.lpstrFilter = "PNG Images (*.png)\0*.png\0";
        ofn.nFilterIndex = 1;
        ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_EXPLORER;

        if (GetOpenFileNameA(&ofn)) {
            if (!endsWithIgnoreCase(filePath, ".png")) {
                showMessage("Select a .png file for the custom skin.", MB_ICONWARNING | MB_OK);
                return;
            }
            setSelectedCustomSkin(filePath);
        }
    }

    static void handleReset() {
        clearPathValue(g_cartPath, g_cartEdit);
        clearPathValue(g_skinPath, g_skinEdit);
        applyDefaultPaths();
        applyToggleState(kDefaultToggles);
        updateGenerateEnabled();
    }

    static void setBusy(bool busy) {
        EnableWindow(g_browseCartButton, !busy);
        EnableWindow(g_browseSkinButton, !busy);
        EnableWindow(g_resetButton, !busy);
        EnableWindow(g_generateButton, !busy && fileExists(g_cartPath) && (hasEmbeddedTemplate() || (g_makePath[0] != '\0' && fileExists(g_makePath))));
        SetWindowTextA(g_generateButton, busy ? "Generating..." : "Generate");
    }

    static void handleGenerate(HWND hwnd) {
        if (!g_cartPath[0] || !fileExists(g_cartPath)) {
            showMessage("Select a .p8.png cart first.", MB_ICONWARNING | MB_OK);
            return;
        }

        if (!hasEmbeddedTemplate() && (!g_makePath[0] || !fileExists(g_makePath))) {
            showMessage(
                "Template ROM not found.\n\n"
                "Build it with: make template\n"
                "Then place REAL8_GBA_template.gba next to pico2gba.exe\n",
                MB_ICONERROR | MB_OK);
            return;
        }

        char outputPath[MAX_PATH] = "";
        if (!buildOutputPath(g_cartPath, outputPath, sizeof(outputPath))) {
            showMessage("Failed to build output path.", MB_ICONERROR | MB_OK);
            return;
        }

        if (g_building) {
            showMessage("Build already in progress.", MB_ICONWARNING | MB_OK);
            return;
        }

        BuildParams* params = new BuildParams();
        params->hwnd = hwnd;
        // In standalone mode, "makePath" is repurposed to mean "template ROM path".
        params->makePath = g_makePath;
        params->cartPath = g_cartPath;
        params->outputPath = outputPath;
        params->logPath.clear();
        params->toggles = readToggleStateFromUi();

        setBusy(true);
        startSpinner(hwnd);

        uintptr_t thread = _beginthreadex(nullptr, 0, buildThreadProc, params, 0, nullptr);
        if (thread == 0) {
            stopSpinner(hwnd);
            setBusy(false);
            showMessage("Failed to start build thread.", MB_ICONERROR | MB_OK);
            delete params;
            return;
        }
        g_buildThread = reinterpret_cast<HANDLE>(thread);
    }

    LRESULT CALLBACK windowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
        switch (msg) {
        case WM_CREATE: {
            RECT rect{};
            GetClientRect(hwnd, &rect);

            const int contentWidth = rect.right - (kPadding * 2);
            const int editWidth = contentWidth - (kButtonWidth + 10);
            const int buttonX = rect.right - kPadding - kButtonWidth;

            const int topRowWidth = contentWidth - kRowGap;
            int leftColumnWidth = (topRowWidth * 7) / 10;
            if (leftColumnWidth < 200) leftColumnWidth = 200;
            int logoMaxWidth = topRowWidth - leftColumnWidth;
            if (logoMaxWidth < 1) logoMaxWidth = 1;

            const int bannerMaxHeight = (16 + 18 + 24) * 2 + kRowGap;
            int bannerDisplayHeight = bannerMaxHeight;
            int bannerDisplayWidth = logoMaxWidth;

            std::string logoErr;
            COLORREF bgColor = getWindowBackgroundColor(hwnd);
            std::vector<uint8_t> logoBytes;
            if (hasEmbeddedResource(kLogoPngResourceId) &&
                loadEmbeddedLogoPng(logoBytes, logoErr)) {
                g_logoBitmap = loadPngBitmapFromMemory(logoBytes.data(), logoBytes.size(),
                                                       logoMaxWidth, bannerMaxHeight, bgColor,
                                                       &bannerDisplayWidth, &bannerDisplayHeight, logoErr);
            }
            if (!g_logoBitmap) {
                char logoPath[MAX_PATH] = "";
                if (findLogoPath(logoPath, sizeof(logoPath))) {
                    g_logoBitmap = loadPngBitmap(logoPath, logoMaxWidth, bannerMaxHeight, bgColor,
                                                 &bannerDisplayWidth, &bannerDisplayHeight, logoErr);
                }
            }

            int logoX = rect.right - kPadding - bannerDisplayWidth;
            int logoY = rect.bottom - kPadding - bannerDisplayHeight;
            if (logoX < kPadding) logoX = kPadding;
            if (logoY < kPadding) logoY = kPadding;

            g_logoImage = CreateWindowExA(0, "STATIC", "", WS_CHILD | WS_VISIBLE | SS_BITMAP,
                                          logoX, logoY, bannerDisplayWidth, bannerDisplayHeight,
                                          hwnd, nullptr, GetModuleHandleA(nullptr), nullptr);
            if (g_logoImage && g_logoBitmap) {
                SendMessageA(g_logoImage, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)g_logoBitmap);
            }

            const int step4BaseY = kPadding;

            CreateWindowExA(
                0,
                "STATIC",
                "Select .p8.png cart",
                WS_CHILD | WS_VISIBLE,
                kPadding,
                step4BaseY,
                contentWidth,
                16,
                hwnd,
                nullptr,
                GetModuleHandleA(nullptr),
                nullptr);

            g_cartEdit = CreateWindowExA(
                WS_EX_CLIENTEDGE,
                "EDIT",
                "",
                WS_CHILD | WS_VISIBLE | ES_AUTOHSCROLL | ES_READONLY,
                kPadding,
                step4BaseY + 18,
                editWidth,
                24,
                hwnd,
                nullptr,
                GetModuleHandleA(nullptr),
                nullptr);

            g_browseCartButton = CreateWindowExA(
                0,
                "BUTTON",
                "Browse...",
                WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
                buttonX,
                step4BaseY + 18,
                kButtonWidth,
                24,
                hwnd,
                (HMENU)kIdBrowseCart,
                GetModuleHandleA(nullptr),
                nullptr);

            CreateWindowExA(
                0,
                "STATIC",
                "Select custom Skin (Optional)",
                WS_CHILD | WS_VISIBLE,
                kPadding,
                step4BaseY + 52,
                contentWidth,
                16,
                hwnd,
                nullptr,
                GetModuleHandleA(nullptr),
                nullptr);

            g_skinEdit = CreateWindowExA(
                WS_EX_CLIENTEDGE,
                "EDIT",
                "",
                WS_CHILD | WS_VISIBLE | ES_AUTOHSCROLL | ES_READONLY,
                kPadding,
                step4BaseY + 70,
                editWidth,
                24,
                hwnd,
                nullptr,
                GetModuleHandleA(nullptr),
                nullptr);

            g_browseSkinButton = CreateWindowExA(
                0,
                "BUTTON",
                "Browse...",
                WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
                buttonX,
                step4BaseY + 70,
                kButtonWidth,
                24,
                hwnd,
                (HMENU)kIdBrowseSkin,
                GetModuleHandleA(nullptr),
                nullptr);

            const int toggleLabelY = step4BaseY + 104;
            CreateWindowExA(
                0,
                "STATIC",
                "Feature toggles",
                WS_CHILD | WS_VISIBLE,
                kPadding,
                toggleLabelY,
                leftColumnWidth,
                16,
                hwnd,
                nullptr,
                GetModuleHandleA(nullptr),
                nullptr);

            const int checkboxYStart = toggleLabelY + 18;
            const int checkboxWidth = (leftColumnWidth - kCheckboxColumnGap) / 2;
            const int checkboxRightX = kPadding + checkboxWidth + kCheckboxColumnGap;
            int checkboxY = checkboxYStart;

            g_toggleAudio = CreateWindowExA(
                0,
                "BUTTON",
                "Enable Audio",
                WS_CHILD | WS_VISIBLE | BS_AUTOCHECKBOX,
                kPadding,
                checkboxY,
                checkboxWidth,
                kCheckboxHeight,
                hwnd,
                (HMENU)kIdToggleAudio,
                GetModuleHandleA(nullptr),
                nullptr);

            g_toggleCflahBase = CreateWindowExA(
                0,
                "BUTTON",
                "Use Custom Skin",
                WS_CHILD | WS_VISIBLE | BS_AUTOCHECKBOX,
                checkboxRightX,
                checkboxY,
                checkboxWidth,
                kCheckboxHeight,
                hwnd,
                (HMENU)kIdToggleCflahBase,
                GetModuleHandleA(nullptr),
                nullptr);

            checkboxY += kCheckboxHeight + kCheckboxRowGap;

            g_toggleSkipVblank = CreateWindowExA(
                0,
                "BUTTON",
                "Skip VBlank",
                WS_CHILD | WS_VISIBLE | BS_AUTOCHECKBOX,
                kPadding,
                checkboxY,
                checkboxWidth,
                kCheckboxHeight,
                hwnd,
                (HMENU)kIdToggleSkipVblank,
                GetModuleHandleA(nullptr),
                nullptr);

            g_toggleProfile = CreateWindowExA(
                0,
                "BUTTON",
                "Profile GBA",
                WS_CHILD | WS_VISIBLE | BS_AUTOCHECKBOX,
                checkboxRightX,
                checkboxY,
                checkboxWidth,
                kCheckboxHeight,
                hwnd,
                (HMENU)kIdToggleProfile,
                GetModuleHandleA(nullptr),
                nullptr);

            applyToggleState(kDefaultToggles);

            const int generateY = checkboxY + kCheckboxHeight + 10;
            const int resetX = kPadding;
            const int generateX = kPadding + kButtonWidth + 10;
            g_resetButton = CreateWindowExA(
                0,
                "BUTTON",
                "Reset",
                WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
                resetX,
                generateY,
                kButtonWidth,
                kButtonHeight,
                hwnd,
                (HMENU)kIdReset,
                GetModuleHandleA(nullptr),
                nullptr);

            g_generateButton = CreateWindowExA(
                0,
                "BUTTON",
                "Generate",
                WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
                generateX,
                generateY,
                kButtonWidth,
                kButtonHeight,
                hwnd,
                (HMENU)kIdGenerate,
                GetModuleHandleA(nullptr),
                nullptr);

            g_spinner = CreateWindowExA(
                0,
                "STATIC",
                "",
                WS_CHILD | WS_VISIBLE | SS_CENTER,
                generateX + kButtonWidth + 8,
                generateY,
                24,
                kButtonHeight,
                hwnd,
                (HMENU)kIdSpinner,
                GetModuleHandleA(nullptr),
                nullptr);

            // Default template path (expects REAL8_GBA_template.gba next to the exe).
            applyDefaultPaths();

            ensureCustomSkinToggle();

            updateGenerateEnabled();
            break;
        }
        case WM_COMMAND: {
            const int id = LOWORD(wParam);
            if (id == kIdBrowseCart) {
                handleBrowseCart(hwnd);
            } else if (id == kIdBrowseSkin) {
                handleBrowseCustomSkin(hwnd);
            } else if (id == kIdReset) {
                handleReset();
            } else if (id == kIdGenerate) {
                handleGenerate(hwnd);
            }
            break;
        }
        case WM_TIMER: {
            if (wParam == kIdSpinnerTimer && g_building && g_spinner) {
                static const char* frames = "|/-\\";
                static int frame = 0;
                char text[2] = { frames[frame], '\0' };
                frame = (frame + 1) % 4;
                SetWindowTextA(g_spinner, text);
            }
            break;
        }
        case kMsgBuildDone: {
            BuildResult* result = reinterpret_cast<BuildResult*>(lParam);
            stopSpinner(hwnd);
            setBusy(false);
            if (result) {
                showMessage(result->message.c_str(), wParam ? (MB_ICONINFORMATION | MB_OK) : (MB_ICONERROR | MB_OK));
                delete result;
            }
            if (g_buildThread) {
                CloseHandle(g_buildThread);
                g_buildThread = nullptr;
            }
            break;
        }
        case WM_CLOSE:
            DestroyWindow(hwnd);
            break;
        case WM_DESTROY:
            if (g_logoBitmap) {
                DeleteObject(g_logoBitmap);
                g_logoBitmap = nullptr;
            }
            PostQuitMessage(0);
            break;
        default:
            return DefWindowProcA(hwnd, msg, wParam, lParam);
        }
        return 0;
    }
}

int WINAPI WinMain(HINSTANCE instance, HINSTANCE, LPSTR, int cmdShow) {
    const char* className = "Pico2GbaWindow";
    HICON appIcon = LoadIconA(instance, kIconResourceName);
    if (!appIcon) {
        appIcon = LoadIconA(nullptr, IDI_APPLICATION);
    }

    WNDCLASSA wc = {};
    wc.lpfnWndProc = windowProc;
    wc.hInstance = instance;
    wc.lpszClassName = className;
    wc.hCursor = LoadCursor(nullptr, IDC_ARROW);
    wc.hIcon = appIcon;
    g_windowBrush = CreateSolidBrush(RGB(0xF0, 0xF0, 0xF0));
    wc.hbrBackground = g_windowBrush ? g_windowBrush : (HBRUSH)(COLOR_WINDOW + 1);

    if (!RegisterClassA(&wc)) {
        return 1;
    }

    std::string title = std::string("Pico2GBA v") + " v" + IReal8Host::REAL8_VERSION + " by @natureglass";
    HWND hwnd = CreateWindowExA(
        0,
        className,
        title.c_str(),
        WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        560,
        265,
        nullptr,
        nullptr,
        instance,
        nullptr);

    if (!hwnd) {
        return 1;
    }

    if (appIcon) {
        SendMessageA(hwnd, WM_SETICON, ICON_BIG, (LPARAM)appIcon);
        SendMessageA(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)appIcon);
    }

    ShowWindow(hwnd, cmdShow);
    UpdateWindow(hwnd);

    MSG msg{};
    while (GetMessageA(&msg, nullptr, 0, 0) > 0) {
        TranslateMessage(&msg);
        DispatchMessageA(&msg);
    }

    if (g_windowBrush) {
        DeleteObject(g_windowBrush);
        g_windowBrush = nullptr;
    }

    return 0;
}
